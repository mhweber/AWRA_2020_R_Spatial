--- 
title: "Fundamentals of Spatial Analysis in R"
author: "Marc Weber"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
description: "This is a draft of material for the Fundamentals of Spatial Analysis in R workshop at the AWRA Spring Conference in Austin in March 2020."
always_allow_html: true
---

# Introduction {#intro}
- A bit about me

```{r, fig.cap="Raster Data", echo=FALSE, out.width="100%"}
knitr::include_graphics("images/WordCloud.png")
```

- A bit about you

- What are you expected to know?
  
  + Basic R objects and methods
  + `tidyverse` packages and syntax
    - i.e. `ggplot2`, `dplyr`, `readr`, `tidyr`, the pipe operator %>% 
  + Very basic familiarity with RMarkdown and with git
  + If these are new, don't sweat it - google them, we'll talk through them as we go if needed
- This portion of workshop there is no expectation of experience with spatial analyisis in R - if you already have some experience, you are sure to pick up new tricks - if you don't, we'll cover all the basics

### Overview 
```{r, fig.cap="History of R", echo=FALSE, out.width="150%"}
knitr::include_graphics("images/History of R.png")
```

What is R and why should we use R for spatial analysis? Letâ€™s break that into two questions - first, what is R and why should we use it?

- A language and environment for statistical computing and graphics
- R is lightweight, free, open-source and cross-platform
- Works with contributed packages - currently 15,362 - extensibility
- Automation and recording of workflow (reproducibility)
- Optimized work flow - data manipulation, analysis and visualization all in one place
- R does not alter underlying data - manipulation and visualization in memory
- R is great for repetetive graphics

Second, why use R for spatial, or GIS, work?

- Spatial and statistical analysis in one environment
- Leverage statistical power of R (i.e.  modeling spatial data, data visualization, statistical exploration)
- Can handle vector and raster data, as well as work with spatial databases and pretty much any data format spatial data comes in
- R's GIS capabilities growing rapidly right now - new packages added monthly - currently about 200 spatial packages (depending on how you categorize)

Some drawbacks to using R for GIS work

- R not as good for interactive use as desktop GIS applications like ArcGIS or QGIS (i.e. editing features, panning, zooming, and analysis on selected subsets of features)
- Explicit coordinate system handling by the user, no on-the-fly projection support
- In memory analysis does not scale well with large GIS vector and tabular data
- Steep learning curve
- Up to you to find packages to do what you need - help not always great

## Quick R basics review 

```{r, eval=FALSE}
getwd()
```

Which should return something like:
```r
[1] "/home/marc/GitProjects/AWRA_GIS_R_Workshop"
```

To see what is in the directory:
```{r}
dir()
```

To establish a different directory:
```r
setwd("/home/marc/GitProjects")
```

#### **Terminology: data structures**
R is an interpreted language (access through a command-line interpreter) with a number of data structures (vectors, matrices, arrays, data frames, lists) and extensible objects (regression models, time-series, geospatial coordinates) and supports procedural programming with functions. 

To learn about objects, become friends with the built-in `class` and `str` functions. Let's explore the built-in iris data set to start:

```{r}
class(iris)
```


```{r}
str(iris)
```

As we can see, `iris` is a data frame and is used extensively for beginning tutorials on learning R. Data frames consist of rows of observations  on columns of values for variables of interest - they are one of the fundamental and most important data structures in R. 

But as we see in the result of `str(iris)` above, following the information that `iris` is a data frame with 150 observations of 5 variables, we get information on each of the variables, in this case that 4 are numeric and one is a factor with three levels.

First off, R has several main data types:

* logical
* integer
* double
* complex
* character
* raw
* list
* NULL
* closure (function)
* special
* builtin (basic functions and operators)
* environment
* S4 (some S4 objects)
* others you won't run into at user level

We can ask what data type something is using `typeof`:
```r
typeof(iris)
```
```r
[1] "list"
```
```r
typeof(iris$Sepal.Length)
```
```r
[1] "double"
```
```r
typeof(iris$Specis)
```
```r
[1] "integer"
```

We see a couple interesting things here - `iris`, which we just said is a data frame, is a data type of `list`.  `Sepal.Length` is data type `double`, and in `str(iris)` we saw it was numeric - that makes sense - but we see that `Species` is data type `integer`, and in `str(iris)` we were told this variable was a factor with three levels.  What's going on here?

First off, `class` refers to the abstract type of an object in R, whereas `typeof` or `mode` refer to how an object is stored in memory. So iris is an object of class `data.frame`, but it is stored in memory as a list (i.e. each column is an item in a list).  Note that this allows data frames to have columns of different classes, whereas a matrix needs to be all of the same mode.

For our `Species` column, We see it's `mode` is numeric, it's `typeof` is `integer`, and it's class is `factor`.  Nominal variables in R are treated as a vector of integers 1:k,  where k is the number of unique values of that nominal variable and a mapping of the character strings to these integer values.  

This allows us to quickly see see all the unique values of a particular nominal variable or quickly re-asign a level of a nominal variable to a new value - remember, everything in R is in memory, so don't worry about tweaking the data!
```r
levels(iris$Species)
levels(iris$Species)[1] <- 'sibirica'
```

See if you can explain how that re-asignment we just did worked.

To access particular columns in a data frame, as we saw above, we use the `$` operator - we can see the value for `Species` for each observation in `iris by doing:
```r
iris$Species
```

To access particular columns or rows of a data frame, we use indexing:
```r
iris[1,3] # the 1st row and the 3rd column
```
```r
[1] 1.4
```
```r
iris[4,5] # the 4th row and the 5th column
```
```r
[1] sibirica
Levels: sibirica versicolor virginica
```

A handy function is `names`, which you can use to get or to set data frame variable names:
```r
names(iris)
names(iris)[1] <- 'Length of Sepal'
```

Explain what this last line did

#### **Overview of Classes and Methods**

- Class: object types
    - `class()`: gives the class type 
    - `typeof()`: information on how the object is stored
    - `str()`: how the object is structured
- Method: generic functions
    - `print()`
    - `plot()`
    - `summary()


## Workshop Data and Logistics

- Downloading content via Github
- Using RMarkdown and RStudio
- Schedule

## Spatial Data in R

We can represent spatial data as discrete locations (points, lines or polygons) or as a grid of values rendered on a map as pixels. We typically represent the former type of data (discrete locations) as *vector* data, with an associated geometry or shape, and some attributes with information about the locations. Examples are:

- state boundaries with state name and population
- rivers with their flow volume and names
- polygons of watersheds with their names and associated landscape information

We represent the latter type of data (a grid of values as pixels) with *rasters*.  Rasters can be continous (i.e. elevation, precipitation, atmospheric deposition) or they can be categorical (i.e. land use, soil type) - they can also be image based rasters, and they can be single band or multi-band.

```{r, fig.cap="Raster Data", echo=FALSE, out.width="100%"}
knitr::include_graphics("images/Rasters4.png")
```

We will delve into working with each of these types of data in their own sections, but let's go over how these spatial data types are handled in R briefly.

Basic data structures in R can represent spatial data - all we need is some vectors with location and attribute information - below we generate cites with population, add a polygon, and make a map with a legend - take a minute to run this code in your own R session and make sure you understand what each line is doing.

```{r basic spatial data structures example}
cities <- c('Ashland','Corvallis','Bend','Portland','Newport')
longitude <- c(-122.699, -123.275, -121.313, -122.670, -124.054)
latitude <- c(42.189, 44.57, 44.061, 45.523, 44.652)
population <- c(20062,50297,61362,537557,9603)
locs <- cbind(longitude, latitude) 
plot(locs, cex=sqrt(population*.0002), pch=20, col='red', 
  main='Population', xlim = c(-124,-120.5), ylim = c(42, 46))
text(locs, cities, pos=4)

# Add a legend
breaks <- c(20000, 50000, 60000, 100000)
options(scipen=3)
legend("topright", legend=breaks, pch=20, pt.cex=1+breaks/20000, 
  col='red', bg='gray')

# Add polygon
lon <- c(-123.5, -123.5, -122.5, -122.670, -123)
lat <- c(43, 45.5, 44, 43, 43)
x <- cbind(lon, lat)
polygon(x, border='blue')
lines(x, lwd=3, col='red')
points(x, cex=2, pch=20)
```

We can see in this toy example that numeric vectors can represent locations in R for simple mapping. Points just need to be a pair of numbers in cartesian space, and lines and polygons are just a number of these points (note that polygons are closed by having their first point coincide with last point which the polygon function in base R graphics takes care of).

You can do simple things with this spatial representation using basic R structures, but it breaks down quickly if you want to ask any spatial questions - for instance using the example above, how would we figure out the nearest city to Corvallis? Or imagine the polygon is a county and we wanted to know what cities are within the county?

### Challenge {.challenge}

What information do we need to properly define spatial vector data and perform spatial operations?

### Answer {.solution} 

- A coordinate reference system (CRS)
- A bounding box or extent
- Methods for storing and accessing spatial attributes of data
- ?

### Packages for vector and raster data in R

```{r spatial packages}
# devtools::install_github("metacran/cranlogs")
library(cranlogs)
library(ggplot2)
library(lubridate)
library(dplyr)
options(scipen=3)
stats <- cran_downloads(from = "2018-01-01", to = "2020-04-01",packages = c("sp", "sf", "raster", "tmap", "mapview", "ggmap", "stars"))

monthly_stats <- stats %>% 
  group_by(month=floor_date(date, "month"), package) %>%
  summarize(amount=sum(count))
ggplot(monthly_stats, aes(x=month, y=amount, group = package, colour = package)) + geom_line(size=1.5) + scale_colour_brewer(palette="Set1")
```

Moving on from sp
```{r, fig.cap="Moving on from `sp`", echo=FALSE, out.width="75%"}
knitr::include_graphics("images/Prehistoric.jpg")
```


- will focus on `sf` for vector data
- st_ syntax in `sf` - stands for spatiotemporal, same convention as in PostGIS
- will focus on `raster` package for raster data and introduce `stars` - short for 'spatio-temporal arrays' - package.  Deals with raster AND vector 'datacubes'

## Code along
Just a sampling of things we'll cover.  Run code, examine output, ask any questions - we'll explore it all in more detail through the morning.

### Geocoding example with tmaptools using open street map

```{r geocode-osm example}
# uses OSM
library(tmap)
library(tmaptools)
library(dplyr)
tex_cap <-tmaptools::geocode_OSM("Texas Capital", 
        as.sf = TRUE) %>% 
  glimpse()
```

### Interactive mapping

```{r mapview example, fig.width=8}
library(mapview)
mapview(tex_cap)
```

### Choropleth map
The package maps (automatically installed and loaded with ggplot2) provides maps of the USA, with state and county borders, that can be retrieved and converted as sf objects:
```{r tmap example, fig.width=8}
library(sf)
library(maps)
counties <- st_as_sf(map("county", plot = FALSE, fill = TRUE))
counties <- subset(counties, grepl("texas", counties$ID) & !grepl('missouri,texas',counties$ID))
counties$area <- as.numeric(st_area(counties))
head(counties)

tm_shape(counties) +
  tm_polygons("area", 
              style="quantile", 
              title="Texas Counties Area")
```



## Challenge: Does this work? {.challenge}

Did my .css styling adjustment work?

### Answer {.solution} 

1. Yes
2. No
