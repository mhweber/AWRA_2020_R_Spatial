--- 
title: "Fundamentals of Spatial Analysis in R"
author: "Marc Weber"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
description: "This is a draft of material for the Fundamentals of Spatial Analysis in R workshop at the AWRA Spring Conference in Austin in March 2020."
always_allow_html: true
---

# Introduction {#intro}

```{r, fig.cap="A bit about me", echo=FALSE, out.width="100%"}
knitr::include_graphics("images/WordCloud.png")
```

- A bit about you

- What are you expected to know?
  
  + Basic R objects and methods
  + `tidyverse` packages and syntax
    - i.e. `ggplot2`, `dplyr`, `readr`, `tidyr`, the pipe operator %>% 
  + Very basic familiarity with RMarkdown and with git
  + If these are new, don't sweat it - google them, we'll talk through them as we go if needed
- This portion of workshop there is no expectation of experience with spatial analyisis in R - if you already have some experience, you are sure to pick up new tricks - if you don't, we'll cover all the basics

## Workshop Data and Logistics
- Packages you need installed
- Downloading content via Github
- Using RMarkdown and RStudio
- Schedule

### Overview 
```{r, fig.cap="History of R", echo=FALSE, out.width="150%"}
knitr::include_graphics("images/History of R.png")
```

What is R and why should we use R for spatial analysis? Letâ€™s break that into two questions - first, what is R and why should we use it?

- A language and environment for statistical computing and graphics
- R is lightweight, free, open-source and cross-platform
- Works with contributed packages - currently 15,362 - extensibility
- Automation and recording of workflow (reproducibility)
- Optimized work flow - data manipulation, analysis and visualization all in one place
- R does not alter underlying data - manipulation and visualization in memory
- R is great for repetetive graphics

Second, why use R for spatial, or GIS, work?

- Spatial and statistical analysis in one environment
- Leverage statistical power of R (i.e.  modeling spatial data, data visualization, statistical exploration)
- Can handle vector and raster data, as well as work with spatial databases and pretty much any data format spatial data comes in
- R's GIS capabilities growing rapidly right now - new packages added monthly - currently about 200 spatial packages (depending on how you categorize)

Some drawbacks to using R for GIS work

- R not as good for interactive use as desktop GIS applications like ArcGIS or QGIS (i.e. editing features, panning, zooming, and analysis on selected subsets of features)
- Explicit coordinate system handling by the user, no on-the-fly projection support
- In memory analysis does not scale well with large GIS vector and tabular data
- Steep learning curve
- Up to you to find packages to do what you need - help not always great

## R Basics Review 

```{r, eval=FALSE}
getwd()
```

Which should return something like:
```r
[1] "/home/marc/GitProjects/AWRA_GIS_R_Workshop"
```

To see what is in the directory:
```{r}
dir()
```

To establish a different directory:
```r
setwd("/home/marc/GitProjects")
```

#### **Terminology: data structures**
R is an interpreted language (access through a command-line interpreter) with a number of data structures (vectors, matrices, arrays, data frames, lists) and extensible objects (regression models, time-series, geospatial coordinates) and supports procedural programming with functions. 

To learn about objects, become friends with the built-in `class` and `str` functions. Let's explore the built-in iris data set to start:

```{r}
class(iris)
```


```{r}
str(iris)
```

As we can see, `iris` is a data frame and is used extensively for beginning tutorials on learning R. Data frames consist of rows of observations  on columns of values for variables of interest - they are one of the fundamental and most important data structures in R. 

But as we see in the result of `str(iris)` above, following the information that `iris` is a data frame with 150 observations of 5 variables, we get information on each of the variables, in this case that 4 are numeric and one is a factor with three levels.

First off, R has several main data types:

* logical
* integer
* double
* complex
* character
* raw
* list
* NULL
* closure (function)
* special
* builtin (basic functions and operators)
* environment
* S4 (some S4 objects)
* others you won't run into at user level

We can ask what data type something is using `typeof`:
```r
typeof(iris)
```
```r
[1] "list"
```
```r
typeof(iris$Sepal.Length)
```
```r
[1] "double"
```
```r
typeof(iris$Specis)
```
```r
[1] "integer"
```

We see a couple interesting things here - `iris`, which we just said is a data frame, is a data type of `list`.  `Sepal.Length` is data type `double`, and in `str(iris)` we saw it was numeric - that makes sense - but we see that `Species` is data type `integer`, and in `str(iris)` we were told this variable was a factor with three levels.  What's going on here?

First off, `class` refers to the abstract type of an object in R, whereas `typeof` or `mode` refer to how an object is stored in memory. So iris is an object of class `data.frame`, but it is stored in memory as a list (i.e. each column is an item in a list).  Note that this allows data frames to have columns of different classes, whereas a matrix needs to be all of the same mode.

For our `Species` column, We see it's `mode` is numeric, it's `typeof` is `integer`, and it's class is `factor`.  Nominal variables in R are treated as a vector of integers 1:k,  where k is the number of unique values of that nominal variable and a mapping of the character strings to these integer values.  

This allows us to quickly see see all the unique values of a particular nominal variable or quickly re-asign a level of a nominal variable to a new value - remember, everything in R is in memory, so don't worry about tweaking the data!
```r
levels(iris$Species)
levels(iris$Species)[1] <- 'sibirica'
```

See if you can explain how that re-asignment we just did worked.

To access particular columns in a data frame, as we saw above, we use the `$` operator - we can see the value for `Species` for each observation in `iris by doing:
```r
iris$Species
```

To access particular columns or rows of a data frame, we use indexing:
```r
iris[1,3] # the 1st row and the 3rd column
```
```r
[1] 1.4
```
```r
iris[4,5] # the 4th row and the 5th column
```
```r
[1] sibirica
Levels: sibirica versicolor virginica
```

A handy function is `names`, which you can use to get or to set data frame variable names:
```r
names(iris)
names(iris)[1] <- 'Length of Sepal'
```

Explain what this last line did

Another handy technique is passing R statements surrounded by parens - this both prints and stores the result of the statement.
```{r}
(file <- system.file("gpkg/nc.gpkg", package='sf'))
```

#### **Overview of Classes and Methods**

- Class: object types
    - `class()`: gives the class type 
    - `typeof()`: information on how the object is stored
    - `str()`: how the object is structured
- Method: generic functions
    - `print()`
    - `plot()`
    - `summary()

## Spatial Data in R

We can represent spatial data as discrete locations (points, lines or polygons) or as a grid of values rendered on a map as pixels. We typically represent the former type of data (discrete locations) as *vector* data, with an associated geometry or shape, and some attributes with information about the locations. Examples are:

- state boundaries with state name and population
- rivers with their flow volume and names
- polygons of watersheds with their names and associated landscape information

We represent the latter type of data (a grid of values as pixels) with *rasters*.  Rasters can be continous (i.e. elevation, precipitation, atmospheric deposition) or they can be categorical (i.e. land use, soil type) - they can also be image based rasters, and they can be single band or multi-band.

```{r, fig.cap="Raster Data", echo=FALSE, out.width="100%"}
knitr::include_graphics("images/Rasters4.png")
```

We will delve into working with each of these types of data in their own sections, but let's go over how these spatial data types are handled in R briefly.

Basic data structures in R can represent spatial data - all we need is some vectors with location and attribute information - below we generate cites with population, add a polygon, and make a map with a legend - take a minute to run this code in your own R session and make sure you understand what each line is doing.

```{r basic spatial data structures vector}
cities <- c('Ashland','Corvallis','Bend','Portland','Newport')
longitude <- c(-122.699, -123.275, -121.313, -122.670, -124.054)
latitude <- c(42.189, 44.57, 44.061, 45.523, 44.652)
population <- c(20062,50297,61362,537557,9603)
locs <- cbind(longitude, latitude) 
plot(locs, cex=sqrt(population*.0002), pch=20, col='red', 
  main='Population', xlim = c(-124,-120.5), ylim = c(42, 46))
text(locs, cities, pos=4)

# Add a legend
breaks <- c(20000, 50000, 60000, 100000)
options(scipen=3)
legend("topright", legend=breaks, pch=20, pt.cex=1+breaks/20000, 
  col='red', bg='gray')

# Add polygon
lon <- c(-123.5, -123.5, -122.5, -122.670, -123)
lat <- c(43, 45.5, 44, 43, 43)
x <- cbind(lon, lat)
polygon(x, border='blue')
lines(x, lwd=3, col='red')
points(x, cex=2, pch=20)
```

We can see in this toy example that numeric vectors can represent locations in R for simple mapping. Points just need to be a pair of numbers in cartesian space, and lines and polygons are just a number of these points (note that polygons are closed by having their first point coincide with last point which the polygon function in base R graphics takes care of).

What about raster data?  A raster in essence is simply a matrix of values for raster cells

```{r basic spatial data structures raster}
library('plot.matrix')
# numeric matrix
x <- matrix(runif(35), ncol=5) # create a numeric matrix object
class(x)
#> [1] "matrix"
par(mar=c(5.1, 4.1, 4.1, 4.1)) # adapt margins
plot(x)
```

We have a 'raster' of cell values in columnns and rows - but what is lacking?

You can do simple things with these spatial representations using basic R structures, but it breaks down quickly if you want to ask any spatial questions - for instance using the first example above, how would we figure out the nearest city to Corvallis? Or imagine the polygon is a county and we wanted to know what cities are within the county? Or how would we superimpose our cities on our raster cells?  Or extract the value of a cell at the location of a city?

### Challenge {.challenge}

What information do we need to properly define spatial vector data and perform spatial operations?

### Answer {.solution} 

- A coordinate reference system (CRS)
- A bounding box or extent
- Methods for storing and accessing spatial attributes of data
- ?

### R Spatial Package Landscape

```{r spatial packages, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
# devtools::install_github("metacran/cranlogs")
library(cranlogs, quietly = T)
library(ggplot2, quietly = T)
library(lubridate, quietly = T)
library(dplyr, quietly = T)
options(scipen=3)
stats <- cran_downloads(from = "2018-01-01", to = "2020-04-01",packages = c("sp", "sf", "raster", "tmap", "mapview", "leaflet","ggmap", "stars"))

monthly_stats <- stats %>% 
  group_by(month=floor_date(date, "month"), package) %>%
  summarize(amount=sum(count))
ggplot(monthly_stats, aes(x=month, y=amount, group = package, colour = package)) + geom_line(size=1.5) + scale_colour_brewer(palette="Set1") + ggtitle("R Monthly Spatial Package \n Downloads since 2018")
```

### How did we make this figure? {.challenge}

Look at answer below, run code in your own code editor, see if it makes sense and ask questions

### Answer {.solution} 

```{r spatial packages 2, eval=FALSE}
# devtools::install_github("metacran/cranlogs")
library(cranlogs, quietly = T)
library(ggplot2, quietly = T)
library(lubridate, quietly = T)
library(dplyr, quietly = T)
options(scipen=3)
stats <- cran_downloads(from = "2018-01-01", to = "2020-04-01",packages = c("sp", "sf", "raster", "tmap", "mapview", "leaflet", "ggmap", "stars"))

monthly_stats <- stats %>% 
  group_by(month=floor_date(date, "month"), package) %>%
  summarize(amount=sum(count))
ggplot(monthly_stats, aes(x=month, y=amount, group = package, colour = package)) + geom_line(size=1.5) + scale_colour_brewer(palette="Set1") + ggtitle("R Monthly Spatial Package \n Downloads since 2018")
```

### Primary R spatial packages

```{r, fig.cap="Moving on from `sp`", echo=FALSE, out.width="75%"}
knitr::include_graphics("images/Prehistoric.jpg")
```

`sp` was the core vector spatial data package in R for a number of years, and while still used and while many packages still depend on the package, we will make a clean break in this workshop and focus entirely on the new `sf` package for working with vector data.

This portion of the workshop will focus primarily on the following core packages for working with spatial data in R:
- `sf` - The core package for working with vector data in R
- `raster` - Still the primary spatial package for working with raster data in R
- `mapview` - this is a wrapper package for R `leaflet` package and I find simpler and more intuitive
- `ggolot` and `tmap` -  static plotting and thematic maping
- `dplyr` - Not a spatial package, but `sf` is "tidy-compliant" and we will follow "tidy" workflows in this portion of the workshop for much or our examples

The [R Spatial Task View page](https://cran.r-project.org/web/views/Spatial.html) provides current and comprehensive information on the ecosystem of R packages for working with spatial data - there are hundreds out there for specific tasks - we'll touch on several others besides core packages above this morning.

## Code along
Here is just a sampling of things we'll cover.  Run code, examine output, ask any questions - we'll delve into specifc topics in more detail throughout the morning.

### Geocoding example with tmaptools using open street map
Here we'll use the `tmap` package and `tmaptools` to 'geocode' a named feature in OpenStreetMap import it into our R session as an `sf` feature.

```{r geocode-osm example}
# uses OSM
library(tmap)
library(tmaptools)
library(dplyr)
tex_cap <-tmaptools::geocode_OSM("Texas Capital USA", 
        as.sf = TRUE) %>% 
  glimpse()
```

### Run and examine code chunk above {.challenge}

1. What is the double colon doing?
2. What is the `geocode_OSM` function doing?
3. Explain how the code runs together using the `%>%` chaining operator
4. What is `glimpse`?  Is it useful compared to `head` function? 


### Answer {.solution} 
1. It specifies using `geocode_OSM` from the `tmaptools` package. R gives namespace preference to packages in order loaded; some packages share function names; so it's good practice to disambiguate your functions with the double-colon
2. It is looking up a named feature in OpenStreetMap and returning the coordinates (bonus - we'll delve into more in next section - what coordinate reference system are coordinates in and how to you find out?)
3. You would translate code using the `>%>` operator from:
  - do this `%>%` do that `%>%`  do that
  
  To
  
  - do this *then* do that *then* do that
4. Technically, it's a transposed version of `print` - columns run down page, data across like rows - it additionally gives you the number of observations and variables, and the data type of each column
  - bonus: how would you quickly learn more about `glimpse` from the console?


### Choropleth map
The package maps (automatically installed and loaded with ggplot2) provides maps of the USA, with state and county borders, that can be retrieved and converted as sf objects:
```{r tmap example, fig.width=8}
library(sf)
library(maps)
counties <- st_as_sf(map("county", plot = FALSE, fill = TRUE))
counties <- subset(counties, grepl("texas", counties$ID) & !grepl('missouri,texas',counties$ID))
counties$area <- as.numeric(st_area(counties))
head(counties)

tm_shape(counties) +
  tm_polygons("area", 
              style="quantile", 
              title="Texas Counties Area")
```

### Interactive mapping
```{r mapview example, fig.width=8}
library(mapview)
mapview(tex_cap, col="red", col.regions = "red") + mapview(counties, alpha.regions = .1)
```

We will look in more depth at these and other examples in following sections