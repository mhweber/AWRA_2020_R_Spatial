[
["index.html", "Fundamentals of Spatial Analysis in R Chapter 1 Introduction 1.1 Quick R basics review 1.2 Workshop Data and Logistics 1.3 Spatial Data in R 1.4 Code along", " Fundamentals of Spatial Analysis in R Marc Weber 2020-03-04 Chapter 1 Introduction A bit about me Figure 1.1: Raster Data A bit about you What are you expected to know? Basic R objects and methods tidyverse packages and syntax i.e. ggplot2, dplyr, readr, tidyr, the pipe operator %&gt;% Very basic familiarity with RMarkdown and with git If these are new, don’t sweat it - google them, we’ll talk through them as we go if needed This portion of workshop there is no expectation of experience with spatial analyisis in R - if you already have some experience, you are sure to pick up new tricks - if you don’t, we’ll cover all the basics 1.0.1 Overview Figure 1.2: History of R What is R and why should we use R for spatial analysis? Let’s break that into two questions - first, what is R and why should we use it? A language and environment for statistical computing and graphics R is lightweight, free, open-source and cross-platform Works with contributed packages - currently 15,362 - extensibility Automation and recording of workflow (reproducibility) Optimized work flow - data manipulation, analysis and visualization all in one place R does not alter underlying data - manipulation and visualization in memory R is great for repetetive graphics Second, why use R for spatial, or GIS, work? Spatial and statistical analysis in one environment Leverage statistical power of R (i.e. modeling spatial data, data visualization, statistical exploration) Can handle vector and raster data, as well as work with spatial databases and pretty much any data format spatial data comes in R’s GIS capabilities growing rapidly right now - new packages added monthly - currently about 200 spatial packages (depending on how you categorize) Some drawbacks to using R for GIS work R not as good for interactive use as desktop GIS applications like ArcGIS or QGIS (i.e. editing features, panning, zooming, and analysis on selected subsets of features) Explicit coordinate system handling by the user, no on-the-fly projection support In memory analysis does not scale well with large GIS vector and tabular data Steep learning curve Up to you to find packages to do what you need - help not always great 1.1 Quick R basics review getwd() Which should return something like: [1] &quot;/home/marc/GitProjects/AWRA_GIS_R_Workshop&quot; To see what is in the directory: dir() ## [1] &quot;_after_body.html&quot; &quot;_book&quot; ## [3] &quot;_bookdown.yml&quot; &quot;_bookdown_files&quot; ## [5] &quot;_output.yml&quot; &quot;02-vector.Rmd&quot; ## [7] &quot;03-raster.Rmd&quot; &quot;04-application.Rmd&quot; ## [9] &quot;05-summary.Rmd&quot; &quot;06-references.Rmd&quot; ## [11] &quot;AWRA_2020_R_Spatial.Rmd&quot; &quot;AWRA_2020_R_Spatial.Rproj&quot; ## [13] &quot;AWRA_2020_R_Spatial_files&quot; &quot;book.bib&quot; ## [15] &quot;css&quot; &quot;docs&quot; ## [17] &quot;images&quot; &quot;index.Rmd&quot; ## [19] &quot;js&quot; &quot;packages.bib&quot; ## [21] &quot;preamble.tex&quot; &quot;README.md&quot; To establish a different directory: setwd(&quot;/home/marc/GitProjects&quot;) 1.1.0.1 Terminology: data structures R is an interpreted language (access through a command-line interpreter) with a number of data structures (vectors, matrices, arrays, data frames, lists) and extensible objects (regression models, time-series, geospatial coordinates) and supports procedural programming with functions. To learn about objects, become friends with the built-in class and str functions. Let’s explore the built-in iris data set to start: class(iris) ## [1] &quot;data.frame&quot; str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... As we can see, iris is a data frame and is used extensively for beginning tutorials on learning R. Data frames consist of rows of observations on columns of values for variables of interest - they are one of the fundamental and most important data structures in R. But as we see in the result of str(iris) above, following the information that iris is a data frame with 150 observations of 5 variables, we get information on each of the variables, in this case that 4 are numeric and one is a factor with three levels. First off, R has several main data types: logical integer double complex character raw list NULL closure (function) special builtin (basic functions and operators) environment S4 (some S4 objects) others you won’t run into at user level We can ask what data type something is using typeof: typeof(iris) [1] &quot;list&quot; typeof(iris$Sepal.Length) [1] &quot;double&quot; typeof(iris$Specis) [1] &quot;integer&quot; We see a couple interesting things here - iris, which we just said is a data frame, is a data type of list. Sepal.Length is data type double, and in str(iris) we saw it was numeric - that makes sense - but we see that Species is data type integer, and in str(iris) we were told this variable was a factor with three levels. What’s going on here? First off, class refers to the abstract type of an object in R, whereas typeof or mode refer to how an object is stored in memory. So iris is an object of class data.frame, but it is stored in memory as a list (i.e. each column is an item in a list). Note that this allows data frames to have columns of different classes, whereas a matrix needs to be all of the same mode. For our Species column, We see it’s mode is numeric, it’s typeof is integer, and it’s class is factor. Nominal variables in R are treated as a vector of integers 1:k, where k is the number of unique values of that nominal variable and a mapping of the character strings to these integer values. This allows us to quickly see see all the unique values of a particular nominal variable or quickly re-asign a level of a nominal variable to a new value - remember, everything in R is in memory, so don’t worry about tweaking the data! levels(iris$Species) levels(iris$Species)[1] &lt;- &#39;sibirica&#39; See if you can explain how that re-asignment we just did worked. To access particular columns in a data frame, as we saw above, we use the $ operator - we can see the value for Species for each observation in `iris by doing: iris$Species To access particular columns or rows of a data frame, we use indexing: iris[1,3] # the 1st row and the 3rd column [1] 1.4 iris[4,5] # the 4th row and the 5th column [1] sibirica Levels: sibirica versicolor virginica A handy function is names, which you can use to get or to set data frame variable names: names(iris) names(iris)[1] &lt;- &#39;Length of Sepal&#39; Explain what this last line did Another handy technique is passing R statements surrounded by parens - this both prints and stores the result of the statement. (file &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package=&#39;sf&#39;)) ## [1] &quot;C:/Users/mweber/R/library/sf/gpkg/nc.gpkg&quot; 1.1.0.2 Overview of Classes and Methods Class: object types class(): gives the class type typeof(): information on how the object is stored str(): how the object is structured Method: generic functions print() plot() `summary() 1.2 Workshop Data and Logistics Downloading content via Github Using RMarkdown and RStudio Schedule 1.3 Spatial Data in R We can represent spatial data as discrete locations (points, lines or polygons) or as a grid of values rendered on a map as pixels. We typically represent the former type of data (discrete locations) as vector data, with an associated geometry or shape, and some attributes with information about the locations. Examples are: state boundaries with state name and population rivers with their flow volume and names polygons of watersheds with their names and associated landscape information We represent the latter type of data (a grid of values as pixels) with rasters. Rasters can be continous (i.e. elevation, precipitation, atmospheric deposition) or they can be categorical (i.e. land use, soil type) - they can also be image based rasters, and they can be single band or multi-band. Figure 1.3: Raster Data We will delve into working with each of these types of data in their own sections, but let’s go over how these spatial data types are handled in R briefly. Basic data structures in R can represent spatial data - all we need is some vectors with location and attribute information - below we generate cites with population, add a polygon, and make a map with a legend - take a minute to run this code in your own R session and make sure you understand what each line is doing. cities &lt;- c(&#39;Ashland&#39;,&#39;Corvallis&#39;,&#39;Bend&#39;,&#39;Portland&#39;,&#39;Newport&#39;) longitude &lt;- c(-122.699, -123.275, -121.313, -122.670, -124.054) latitude &lt;- c(42.189, 44.57, 44.061, 45.523, 44.652) population &lt;- c(20062,50297,61362,537557,9603) locs &lt;- cbind(longitude, latitude) plot(locs, cex=sqrt(population*.0002), pch=20, col=&#39;red&#39;, main=&#39;Population&#39;, xlim = c(-124,-120.5), ylim = c(42, 46)) text(locs, cities, pos=4) # Add a legend breaks &lt;- c(20000, 50000, 60000, 100000) options(scipen=3) legend(&quot;topright&quot;, legend=breaks, pch=20, pt.cex=1+breaks/20000, col=&#39;red&#39;, bg=&#39;gray&#39;) # Add polygon lon &lt;- c(-123.5, -123.5, -122.5, -122.670, -123) lat &lt;- c(43, 45.5, 44, 43, 43) x &lt;- cbind(lon, lat) polygon(x, border=&#39;blue&#39;) lines(x, lwd=3, col=&#39;red&#39;) points(x, cex=2, pch=20) We can see in this toy example that numeric vectors can represent locations in R for simple mapping. Points just need to be a pair of numbers in cartesian space, and lines and polygons are just a number of these points (note that polygons are closed by having their first point coincide with last point which the polygon function in base R graphics takes care of). You can do simple things with this spatial representation using basic R structures, but it breaks down quickly if you want to ask any spatial questions - for instance using the example above, how would we figure out the nearest city to Corvallis? Or imagine the polygon is a county and we wanted to know what cities are within the county? 1.3.1 Challenge What information do we need to properly define spatial vector data and perform spatial operations? 1.3.2 Answer A coordinate reference system (CRS) A bounding box or extent Methods for storing and accessing spatial attributes of data ? 1.3.3 Packages for vector and raster data in R # devtools::install_github(&quot;metacran/cranlogs&quot;) library(cranlogs) library(ggplot2) library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:base&#39;: ## ## date library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:lubridate&#39;: ## ## intersect, setdiff, union ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union options(scipen=3) stats &lt;- cran_downloads(from = &quot;2018-01-01&quot;, to = &quot;2020-04-01&quot;,packages = c(&quot;sp&quot;, &quot;sf&quot;, &quot;raster&quot;, &quot;tmap&quot;, &quot;mapview&quot;, &quot;ggmap&quot;, &quot;stars&quot;)) ## Warning in fill_in_dates(df, as.Date(res1$start), as.Date(res1$end)): Time ## interval in the future ## Warning in fill_in_dates(df, as.Date(res1$start), as.Date(res1$end)): Time ## interval in the future ## Warning in fill_in_dates(df, as.Date(res1$start), as.Date(res1$end)): Time ## interval in the future ## Warning in fill_in_dates(df, as.Date(res1$start), as.Date(res1$end)): Time ## interval in the future ## Warning in fill_in_dates(df, as.Date(res1$start), as.Date(res1$end)): Time ## interval in the future ## Warning in fill_in_dates(df, as.Date(res1$start), as.Date(res1$end)): Time ## interval in the future ## Warning in fill_in_dates(df, as.Date(res1$start), as.Date(res1$end)): Time ## interval in the future monthly_stats &lt;- stats %&gt;% group_by(month=floor_date(date, &quot;month&quot;), package) %&gt;% summarize(amount=sum(count)) ggplot(monthly_stats, aes(x=month, y=amount, group = package, colour = package)) + geom_line(size=1.5) + scale_colour_brewer(palette=&quot;Set1&quot;) Moving on from sp Figure 1.4: Moving on from sp 1.4 Code along Just a sampling of things we’ll cover. Run code, examine output, ask any questions - we’ll explore it all in more detail through the morning. 1.4.1 Geocoding example with tmaptools using open street map # uses OSM library(tmap) library(tmaptools) library(dplyr) tex_cap &lt;-tmaptools::geocode_OSM(&quot;Texas Capital&quot;, as.sf = TRUE) %&gt;% glimpse() ## Observations: 1 ## Variables: 8 ## $ query &lt;chr&gt; &quot;Texas Capital&quot; ## $ lat &lt;dbl&gt; -31.46748 ## $ lon &lt;dbl&gt; -64.22844 ## $ lat_min &lt;dbl&gt; -31.46748 ## $ lat_max &lt;dbl&gt; -31.46748 ## $ lon_min &lt;dbl&gt; -64.22995 ## $ lon_max &lt;dbl&gt; -64.22723 ## $ geometry &lt;POINT [°]&gt; POINT (-64.22844 -31.46748) 1.4.2 Interactive mapping library(mapview) mapview(tex_cap) 1.4.3 Choropleth map The package maps (automatically installed and loaded with ggplot2) provides maps of the USA, with state and county borders, that can be retrieved and converted as sf objects: library(sf) ## Linking to GEOS 3.6.1, GDAL 2.2.3, PROJ 4.9.3 library(maps) counties &lt;- st_as_sf(map(&quot;county&quot;, plot = FALSE, fill = TRUE)) counties &lt;- subset(counties, grepl(&quot;texas&quot;, counties$ID) &amp; !grepl(&#39;missouri,texas&#39;,counties$ID)) counties$area &lt;- as.numeric(st_area(counties)) head(counties) ## Simple feature collection with 6 features and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -103.0751 ymin: 28.14942 xmax: -94.13123 ymax: 37.00161 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## ID geom area ## 2165 oklahoma,texas MULTIPOLYGON (((-101.6255 3... 5434507068 ## 2488 texas,anderson MULTIPOLYGON (((-95.75271 3... 2817584981 ## 2489 texas,andrews MULTIPOLYGON (((-102.2042 3... 3962852909 ## 2490 texas,angelina MULTIPOLYGON (((-94.13123 3... 2200352194 ## 2491 texas,aransas MULTIPOLYGON (((-96.80122 2... 290370313 ## 2492 texas,archer MULTIPOLYGON (((-98.42269 3... 2422607253 tm_shape(counties) + tm_polygons(&quot;area&quot;, style=&quot;quantile&quot;, title=&quot;Texas Counties Area&quot;) ## Warning: The shape counties is invalid. See sf::st_is_valid ### Challenge: Chained spatial operation {.challenge} Earlier we showed example of printing and storing a statement using parens (file &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package=&#39;sf&#39;)) ## [1] &quot;C:/Users/mweber/R/library/sf/gpkg/nc.gpkg&quot; How would we read this file into an sf data frame using chained operation? 1.4.4 Answer (file %&gt;% read_sf() -&gt; nc) ## Simple feature collection with 100 features and 14 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## epsg (SRID): 4267 ## proj4string: +proj=longlat +datum=NAD27 +no_defs ## # A tibble: 100 x 15 ## AREA PERIMETER CNTY_ CNTY_ID NAME FIPS FIPSNO CRESS_ID BIR74 SID74 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.114 1.44 1825 1825 Ashe 37009 37009 5 1091 1 ## 2 0.061 1.23 1827 1827 Alle~ 37005 37005 3 487 0 ## 3 0.143 1.63 1828 1828 Surry 37171 37171 86 3188 5 ## 4 0.07 2.97 1831 1831 Curr~ 37053 37053 27 508 1 ## 5 0.153 2.21 1832 1832 Nort~ 37131 37131 66 1421 9 ## 6 0.097 1.67 1833 1833 Hert~ 37091 37091 46 1452 7 ## 7 0.062 1.55 1834 1834 Camd~ 37029 37029 15 286 0 ## 8 0.091 1.28 1835 1835 Gates 37073 37073 37 420 0 ## 9 0.118 1.42 1836 1836 Warr~ 37185 37185 93 968 4 ## 10 0.124 1.43 1837 1837 Stok~ 37169 37169 85 1612 1 ## # ... with 90 more rows, and 5 more variables: NWBIR74 &lt;dbl&gt;, BIR79 &lt;dbl&gt;, ## # SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt; "]
]
